// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef PROTOBUF_data_2eproto__INCLUDED
#define PROTOBUF_data_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace cloudparts {
namespace log {
namespace data {
class LogRec;
class LogRecDefaultTypeInternal;
extern LogRecDefaultTypeInternal _LogRec_default_instance_;
class LogRec_Tag;
class LogRec_TagDefaultTypeInternal;
extern LogRec_TagDefaultTypeInternal _LogRec_Tag_default_instance_;
class TxInfo;
class TxInfoDefaultTypeInternal;
extern TxInfoDefaultTypeInternal _TxInfo_default_instance_;
}  // namespace data
}  // namespace log
}  // namespace cloudparts

namespace cloudparts {
namespace log {
namespace data {

namespace protobuf_data_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_data_2eproto

enum TxInfo_TEvt {
  TxInfo_TEvt_begin = 0,
  TxInfo_TEvt_prepare = 1,
  TxInfo_TEvt_primary_commit = 2,
  TxInfo_TEvt_primary_rollback = 3,
  TxInfo_TEvt_time_out = 4,
  TxInfo_TEvt_branch_begin = 5,
  TxInfo_TEvt_branch_prepare = 6,
  TxInfo_TEvt_branch_commit = 7,
  TxInfo_TEvt_branch_rollback = 8,
  TxInfo_TEvt_branch_time_out = 9,
  TxInfo_TEvt_backup_commit = 10,
  TxInfo_TEvt_backup_rollback = 11,
  TxInfo_TEvt_recovery_begin = 12,
  TxInfo_TEvt_recovery_check = 13,
  TxInfo_TEvt_recovery_complete = 14
};
bool TxInfo_TEvt_IsValid(int value);
const TxInfo_TEvt TxInfo_TEvt_TEvt_MIN = TxInfo_TEvt_begin;
const TxInfo_TEvt TxInfo_TEvt_TEvt_MAX = TxInfo_TEvt_recovery_complete;
const int TxInfo_TEvt_TEvt_ARRAYSIZE = TxInfo_TEvt_TEvt_MAX + 1;

const ::google::protobuf::EnumDescriptor* TxInfo_TEvt_descriptor();
inline const ::std::string& TxInfo_TEvt_Name(TxInfo_TEvt value) {
  return ::google::protobuf::internal::NameOfEnum(
    TxInfo_TEvt_descriptor(), value);
}
inline bool TxInfo_TEvt_Parse(
    const ::std::string& name, TxInfo_TEvt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TxInfo_TEvt>(
    TxInfo_TEvt_descriptor(), name, value);
}
// ===================================================================

class TxInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cloudparts.log.data.TxInfo) */ {
 public:
  TxInfo();
  virtual ~TxInfo();

  TxInfo(const TxInfo& from);

  inline TxInfo& operator=(const TxInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxInfo& default_instance();

  static inline const TxInfo* internal_default_instance() {
    return reinterpret_cast<const TxInfo*>(
               &_TxInfo_default_instance_);
  }

  void Swap(TxInfo* other);

  // implements Message ----------------------------------------------

  inline TxInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TxInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxInfo& from);
  void MergeFrom(const TxInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TxInfo_TEvt TEvt;
  static const TEvt begin =
    TxInfo_TEvt_begin;
  static const TEvt prepare =
    TxInfo_TEvt_prepare;
  static const TEvt primary_commit =
    TxInfo_TEvt_primary_commit;
  static const TEvt primary_rollback =
    TxInfo_TEvt_primary_rollback;
  static const TEvt time_out =
    TxInfo_TEvt_time_out;
  static const TEvt branch_begin =
    TxInfo_TEvt_branch_begin;
  static const TEvt branch_prepare =
    TxInfo_TEvt_branch_prepare;
  static const TEvt branch_commit =
    TxInfo_TEvt_branch_commit;
  static const TEvt branch_rollback =
    TxInfo_TEvt_branch_rollback;
  static const TEvt branch_time_out =
    TxInfo_TEvt_branch_time_out;
  static const TEvt backup_commit =
    TxInfo_TEvt_backup_commit;
  static const TEvt backup_rollback =
    TxInfo_TEvt_backup_rollback;
  static const TEvt recovery_begin =
    TxInfo_TEvt_recovery_begin;
  static const TEvt recovery_check =
    TxInfo_TEvt_recovery_check;
  static const TEvt recovery_complete =
    TxInfo_TEvt_recovery_complete;
  static inline bool TEvt_IsValid(int value) {
    return TxInfo_TEvt_IsValid(value);
  }
  static const TEvt TEvt_MIN =
    TxInfo_TEvt_TEvt_MIN;
  static const TEvt TEvt_MAX =
    TxInfo_TEvt_TEvt_MAX;
  static const int TEvt_ARRAYSIZE =
    TxInfo_TEvt_TEvt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TEvt_descriptor() {
    return TxInfo_TEvt_descriptor();
  }
  static inline const ::std::string& TEvt_Name(TEvt value) {
    return TxInfo_TEvt_Name(value);
  }
  static inline bool TEvt_Parse(const ::std::string& name,
      TEvt* value) {
    return TxInfo_TEvt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string tx_scope = 1;
  bool has_tx_scope() const;
  void clear_tx_scope();
  static const int kTxScopeFieldNumber = 1;
  const ::std::string& tx_scope() const;
  void set_tx_scope(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_scope(::std::string&& value);
  #endif
  void set_tx_scope(const char* value);
  void set_tx_scope(const char* value, size_t size);
  ::std::string* mutable_tx_scope();
  ::std::string* release_tx_scope();
  void set_allocated_tx_scope(::std::string* tx_scope);

  // required uint64 tx_id = 2;
  bool has_tx_id() const;
  void clear_tx_id();
  static const int kTxIdFieldNumber = 2;
  ::google::protobuf::uint64 tx_id() const;
  void set_tx_id(::google::protobuf::uint64 value);

  // optional uint64 tx_branch = 3;
  bool has_tx_branch() const;
  void clear_tx_branch();
  static const int kTxBranchFieldNumber = 3;
  ::google::protobuf::uint64 tx_branch() const;
  void set_tx_branch(::google::protobuf::uint64 value);

  // required .cloudparts.log.data.TxInfo.TEvt tx_event = 4;
  bool has_tx_event() const;
  void clear_tx_event();
  static const int kTxEventFieldNumber = 4;
  ::cloudparts::log::data::TxInfo_TEvt tx_event() const;
  void set_tx_event(::cloudparts::log::data::TxInfo_TEvt value);

  // @@protoc_insertion_point(class_scope:cloudparts.log.data.TxInfo)
 private:
  void set_has_tx_scope();
  void clear_has_tx_scope();
  void set_has_tx_id();
  void clear_has_tx_id();
  void set_has_tx_branch();
  void clear_has_tx_branch();
  void set_has_tx_event();
  void clear_has_tx_event();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_scope_;
  ::google::protobuf::uint64 tx_id_;
  ::google::protobuf::uint64 tx_branch_;
  int tx_event_;
  friend struct  protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogRec_Tag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cloudparts.log.data.LogRec.Tag) */ {
 public:
  LogRec_Tag();
  virtual ~LogRec_Tag();

  LogRec_Tag(const LogRec_Tag& from);

  inline LogRec_Tag& operator=(const LogRec_Tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogRec_Tag& default_instance();

  static inline const LogRec_Tag* internal_default_instance() {
    return reinterpret_cast<const LogRec_Tag*>(
               &_LogRec_Tag_default_instance_);
  }

  void Swap(LogRec_Tag* other);

  // implements Message ----------------------------------------------

  inline LogRec_Tag* New() const PROTOBUF_FINAL { return New(NULL); }

  LogRec_Tag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogRec_Tag& from);
  void MergeFrom(const LogRec_Tag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogRec_Tag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string val = 2;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::std::string& val() const;
  void set_val(const ::std::string& value);
  #if LANG_CXX11
  void set_val(::std::string&& value);
  #endif
  void set_val(const char* value);
  void set_val(const char* value, size_t size);
  ::std::string* mutable_val();
  ::std::string* release_val();
  void set_allocated_val(::std::string* val);

  // @@protoc_insertion_point(class_scope:cloudparts.log.data.LogRec.Tag)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_val();
  void clear_has_val();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr val_;
  friend struct  protobuf_data_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogRec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cloudparts.log.data.LogRec) */ {
 public:
  LogRec();
  virtual ~LogRec();

  LogRec(const LogRec& from);

  inline LogRec& operator=(const LogRec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogRec& default_instance();

  static inline const LogRec* internal_default_instance() {
    return reinterpret_cast<const LogRec*>(
               &_LogRec_default_instance_);
  }

  void Swap(LogRec* other);

  // implements Message ----------------------------------------------

  inline LogRec* New() const PROTOBUF_FINAL { return New(NULL); }

  LogRec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogRec& from);
  void MergeFrom(const LogRec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogRec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LogRec_Tag Tag;

  // accessors -------------------------------------------------------

  // repeated .cloudparts.log.data.LogRec.Tag tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::cloudparts::log::data::LogRec_Tag& tags(int index) const;
  ::cloudparts::log::data::LogRec_Tag* mutable_tags(int index);
  ::cloudparts::log::data::LogRec_Tag* add_tags();
  ::google::protobuf::RepeatedPtrField< ::cloudparts::log::data::LogRec_Tag >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::cloudparts::log::data::LogRec_Tag >&
      tags() const;

  // optional string key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string msg = 5;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 5;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional string svc = 8;
  bool has_svc() const;
  void clear_svc();
  static const int kSvcFieldNumber = 8;
  const ::std::string& svc() const;
  void set_svc(const ::std::string& value);
  #if LANG_CXX11
  void set_svc(::std::string&& value);
  #endif
  void set_svc(const char* value);
  void set_svc(const char* value, size_t size);
  ::std::string* mutable_svc();
  ::std::string* release_svc();
  void set_allocated_svc(::std::string* svc);

  // optional string instance = 9;
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 9;
  const ::std::string& instance() const;
  void set_instance(const ::std::string& value);
  #if LANG_CXX11
  void set_instance(::std::string&& value);
  #endif
  void set_instance(const char* value);
  void set_instance(const char* value, size_t size);
  ::std::string* mutable_instance();
  ::std::string* release_instance();
  void set_allocated_instance(::std::string* instance);

  // optional string session = 10;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 10;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // optional .cloudparts.log.data.TxInfo tx = 7;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 7;
  const ::cloudparts::log::data::TxInfo& tx() const;
  ::cloudparts::log::data::TxInfo* mutable_tx();
  ::cloudparts::log::data::TxInfo* release_tx();
  void set_allocated_tx(::cloudparts::log::data::TxInfo* tx);

  // optional uint64 partition = 1;
  bool has_partition() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 1;
  ::google::protobuf::uint64 partition() const;
  void set_partition(::google::protobuf::uint64 value);

  // optional uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // optional uint64 when = 4;
  bool has_when() const;
  void clear_when();
  static const int kWhenFieldNumber = 4;
  ::google::protobuf::uint64 when() const;
  void set_when(::google::protobuf::uint64 value);

  // optional uint32 facility = 11;
  bool has_facility() const;
  void clear_facility();
  static const int kFacilityFieldNumber = 11;
  ::google::protobuf::uint32 facility() const;
  void set_facility(::google::protobuf::uint32 value);

  // optional uint32 severity = 12;
  bool has_severity() const;
  void clear_severity();
  static const int kSeverityFieldNumber = 12;
  ::google::protobuf::uint32 severity() const;
  void set_severity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cloudparts.log.data.LogRec)
 private:
  void set_has_partition();
  void clear_has_partition();
  void set_has_offset();
  void clear_has_offset();
  void set_has_key();
  void clear_has_key();
  void set_has_when();
  void clear_has_when();
  void set_has_msg();
  void clear_has_msg();
  void set_has_tx();
  void clear_has_tx();
  void set_has_svc();
  void clear_has_svc();
  void set_has_instance();
  void clear_has_instance();
  void set_has_session();
  void clear_has_session();
  void set_has_facility();
  void clear_has_facility();
  void set_has_severity();
  void clear_has_severity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cloudparts::log::data::LogRec_Tag > tags_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::internal::ArenaStringPtr svc_;
  ::google::protobuf::internal::ArenaStringPtr instance_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  ::cloudparts::log::data::TxInfo* tx_;
  ::google::protobuf::uint64 partition_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 when_;
  ::google::protobuf::uint32 facility_;
  ::google::protobuf::uint32 severity_;
  friend struct  protobuf_data_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TxInfo

// optional string tx_scope = 1;
inline bool TxInfo::has_tx_scope() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxInfo::set_has_tx_scope() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxInfo::clear_has_tx_scope() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxInfo::clear_tx_scope() {
  tx_scope_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tx_scope();
}
inline const ::std::string& TxInfo::tx_scope() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.TxInfo.tx_scope)
  return tx_scope_.GetNoArena();
}
inline void TxInfo::set_tx_scope(const ::std::string& value) {
  set_has_tx_scope();
  tx_scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.TxInfo.tx_scope)
}
#if LANG_CXX11
inline void TxInfo::set_tx_scope(::std::string&& value) {
  set_has_tx_scope();
  tx_scope_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.TxInfo.tx_scope)
}
#endif
inline void TxInfo::set_tx_scope(const char* value) {
  set_has_tx_scope();
  tx_scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.TxInfo.tx_scope)
}
inline void TxInfo::set_tx_scope(const char* value, size_t size) {
  set_has_tx_scope();
  tx_scope_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.TxInfo.tx_scope)
}
inline ::std::string* TxInfo::mutable_tx_scope() {
  set_has_tx_scope();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.TxInfo.tx_scope)
  return tx_scope_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInfo::release_tx_scope() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.TxInfo.tx_scope)
  clear_has_tx_scope();
  return tx_scope_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInfo::set_allocated_tx_scope(::std::string* tx_scope) {
  if (tx_scope != NULL) {
    set_has_tx_scope();
  } else {
    clear_has_tx_scope();
  }
  tx_scope_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_scope);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.TxInfo.tx_scope)
}

// required uint64 tx_id = 2;
inline bool TxInfo::has_tx_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxInfo::set_has_tx_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxInfo::clear_has_tx_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxInfo::clear_tx_id() {
  tx_id_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_id();
}
inline ::google::protobuf::uint64 TxInfo::tx_id() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.TxInfo.tx_id)
  return tx_id_;
}
inline void TxInfo::set_tx_id(::google::protobuf::uint64 value) {
  set_has_tx_id();
  tx_id_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.TxInfo.tx_id)
}

// optional uint64 tx_branch = 3;
inline bool TxInfo::has_tx_branch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxInfo::set_has_tx_branch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxInfo::clear_has_tx_branch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxInfo::clear_tx_branch() {
  tx_branch_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_branch();
}
inline ::google::protobuf::uint64 TxInfo::tx_branch() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.TxInfo.tx_branch)
  return tx_branch_;
}
inline void TxInfo::set_tx_branch(::google::protobuf::uint64 value) {
  set_has_tx_branch();
  tx_branch_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.TxInfo.tx_branch)
}

// required .cloudparts.log.data.TxInfo.TEvt tx_event = 4;
inline bool TxInfo::has_tx_event() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxInfo::set_has_tx_event() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxInfo::clear_has_tx_event() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxInfo::clear_tx_event() {
  tx_event_ = 0;
  clear_has_tx_event();
}
inline ::cloudparts::log::data::TxInfo_TEvt TxInfo::tx_event() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.TxInfo.tx_event)
  return static_cast< ::cloudparts::log::data::TxInfo_TEvt >(tx_event_);
}
inline void TxInfo::set_tx_event(::cloudparts::log::data::TxInfo_TEvt value) {
  assert(::cloudparts::log::data::TxInfo_TEvt_IsValid(value));
  set_has_tx_event();
  tx_event_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.TxInfo.tx_event)
}

// -------------------------------------------------------------------

// LogRec_Tag

// required string name = 1;
inline bool LogRec_Tag::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRec_Tag::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRec_Tag::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRec_Tag::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& LogRec_Tag::name() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.Tag.name)
  return name_.GetNoArena();
}
inline void LogRec_Tag::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.Tag.name)
}
#if LANG_CXX11
inline void LogRec_Tag::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.Tag.name)
}
#endif
inline void LogRec_Tag::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.Tag.name)
}
inline void LogRec_Tag::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.Tag.name)
}
inline ::std::string* LogRec_Tag::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.Tag.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec_Tag::release_name() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.Tag.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec_Tag::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.Tag.name)
}

// required string val = 2;
inline bool LogRec_Tag::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRec_Tag::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRec_Tag::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRec_Tag::clear_val() {
  val_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_val();
}
inline const ::std::string& LogRec_Tag::val() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.Tag.val)
  return val_.GetNoArena();
}
inline void LogRec_Tag::set_val(const ::std::string& value) {
  set_has_val();
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.Tag.val)
}
#if LANG_CXX11
inline void LogRec_Tag::set_val(::std::string&& value) {
  set_has_val();
  val_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.Tag.val)
}
#endif
inline void LogRec_Tag::set_val(const char* value) {
  set_has_val();
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.Tag.val)
}
inline void LogRec_Tag::set_val(const char* value, size_t size) {
  set_has_val();
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.Tag.val)
}
inline ::std::string* LogRec_Tag::mutable_val() {
  set_has_val();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.Tag.val)
  return val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec_Tag::release_val() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.Tag.val)
  clear_has_val();
  return val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec_Tag::set_allocated_val(::std::string* val) {
  if (val != NULL) {
    set_has_val();
  } else {
    clear_has_val();
  }
  val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), val);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.Tag.val)
}

// -------------------------------------------------------------------

// LogRec

// optional uint64 partition = 1;
inline bool LogRec::has_partition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogRec::set_has_partition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogRec::clear_has_partition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogRec::clear_partition() {
  partition_ = GOOGLE_ULONGLONG(0);
  clear_has_partition();
}
inline ::google::protobuf::uint64 LogRec::partition() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.partition)
  return partition_;
}
inline void LogRec::set_partition(::google::protobuf::uint64 value) {
  set_has_partition();
  partition_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.partition)
}

// optional uint64 offset = 2;
inline bool LogRec::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogRec::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogRec::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogRec::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 LogRec::offset() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.offset)
  return offset_;
}
inline void LogRec::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.offset)
}

// optional string key = 3;
inline bool LogRec::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRec::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRec::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRec::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& LogRec::key() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.key)
  return key_.GetNoArena();
}
inline void LogRec::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.key)
}
#if LANG_CXX11
inline void LogRec::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.key)
}
#endif
inline void LogRec::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.key)
}
inline void LogRec::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.key)
}
inline ::std::string* LogRec::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec::release_key() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.key)
}

// optional uint64 when = 4;
inline bool LogRec::has_when() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LogRec::set_has_when() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LogRec::clear_has_when() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LogRec::clear_when() {
  when_ = GOOGLE_ULONGLONG(0);
  clear_has_when();
}
inline ::google::protobuf::uint64 LogRec::when() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.when)
  return when_;
}
inline void LogRec::set_when(::google::protobuf::uint64 value) {
  set_has_when();
  when_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.when)
}

// optional string msg = 5;
inline bool LogRec::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRec::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRec::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRec::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& LogRec::msg() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.msg)
  return msg_.GetNoArena();
}
inline void LogRec::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.msg)
}
#if LANG_CXX11
inline void LogRec::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.msg)
}
#endif
inline void LogRec::set_msg(const char* value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.msg)
}
inline void LogRec::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.msg)
}
inline ::std::string* LogRec::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec::release_msg() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.msg)
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.msg)
}

// repeated .cloudparts.log.data.LogRec.Tag tags = 6;
inline int LogRec::tags_size() const {
  return tags_.size();
}
inline void LogRec::clear_tags() {
  tags_.Clear();
}
inline const ::cloudparts::log::data::LogRec_Tag& LogRec::tags(int index) const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.tags)
  return tags_.Get(index);
}
inline ::cloudparts::log::data::LogRec_Tag* LogRec::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.tags)
  return tags_.Mutable(index);
}
inline ::cloudparts::log::data::LogRec_Tag* LogRec::add_tags() {
  // @@protoc_insertion_point(field_add:cloudparts.log.data.LogRec.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cloudparts::log::data::LogRec_Tag >*
LogRec::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:cloudparts.log.data.LogRec.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cloudparts::log::data::LogRec_Tag >&
LogRec::tags() const {
  // @@protoc_insertion_point(field_list:cloudparts.log.data.LogRec.tags)
  return tags_;
}

// optional .cloudparts.log.data.TxInfo tx = 7;
inline bool LogRec::has_tx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogRec::set_has_tx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogRec::clear_has_tx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogRec::clear_tx() {
  if (tx_ != NULL) tx_->::cloudparts::log::data::TxInfo::Clear();
  clear_has_tx();
}
inline const ::cloudparts::log::data::TxInfo& LogRec::tx() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.tx)
  return tx_ != NULL ? *tx_
                         : *::cloudparts::log::data::TxInfo::internal_default_instance();
}
inline ::cloudparts::log::data::TxInfo* LogRec::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) {
    tx_ = new ::cloudparts::log::data::TxInfo;
  }
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.tx)
  return tx_;
}
inline ::cloudparts::log::data::TxInfo* LogRec::release_tx() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.tx)
  clear_has_tx();
  ::cloudparts::log::data::TxInfo* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline void LogRec::set_allocated_tx(::cloudparts::log::data::TxInfo* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.tx)
}

// optional string svc = 8;
inline bool LogRec::has_svc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogRec::set_has_svc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogRec::clear_has_svc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogRec::clear_svc() {
  svc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_svc();
}
inline const ::std::string& LogRec::svc() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.svc)
  return svc_.GetNoArena();
}
inline void LogRec::set_svc(const ::std::string& value) {
  set_has_svc();
  svc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.svc)
}
#if LANG_CXX11
inline void LogRec::set_svc(::std::string&& value) {
  set_has_svc();
  svc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.svc)
}
#endif
inline void LogRec::set_svc(const char* value) {
  set_has_svc();
  svc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.svc)
}
inline void LogRec::set_svc(const char* value, size_t size) {
  set_has_svc();
  svc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.svc)
}
inline ::std::string* LogRec::mutable_svc() {
  set_has_svc();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.svc)
  return svc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec::release_svc() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.svc)
  clear_has_svc();
  return svc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec::set_allocated_svc(::std::string* svc) {
  if (svc != NULL) {
    set_has_svc();
  } else {
    clear_has_svc();
  }
  svc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), svc);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.svc)
}

// optional string instance = 9;
inline bool LogRec::has_instance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogRec::set_has_instance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogRec::clear_has_instance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogRec::clear_instance() {
  instance_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_instance();
}
inline const ::std::string& LogRec::instance() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.instance)
  return instance_.GetNoArena();
}
inline void LogRec::set_instance(const ::std::string& value) {
  set_has_instance();
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.instance)
}
#if LANG_CXX11
inline void LogRec::set_instance(::std::string&& value) {
  set_has_instance();
  instance_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.instance)
}
#endif
inline void LogRec::set_instance(const char* value) {
  set_has_instance();
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.instance)
}
inline void LogRec::set_instance(const char* value, size_t size) {
  set_has_instance();
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.instance)
}
inline ::std::string* LogRec::mutable_instance() {
  set_has_instance();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.instance)
  return instance_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec::release_instance() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.instance)
  clear_has_instance();
  return instance_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec::set_allocated_instance(::std::string* instance) {
  if (instance != NULL) {
    set_has_instance();
  } else {
    clear_has_instance();
  }
  instance_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.instance)
}

// optional string session = 10;
inline bool LogRec::has_session() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogRec::set_has_session() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogRec::clear_has_session() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogRec::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session();
}
inline const ::std::string& LogRec::session() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.session)
  return session_.GetNoArena();
}
inline void LogRec::set_session(const ::std::string& value) {
  set_has_session();
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.session)
}
#if LANG_CXX11
inline void LogRec::set_session(::std::string&& value) {
  set_has_session();
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cloudparts.log.data.LogRec.session)
}
#endif
inline void LogRec::set_session(const char* value) {
  set_has_session();
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cloudparts.log.data.LogRec.session)
}
inline void LogRec::set_session(const char* value, size_t size) {
  set_has_session();
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cloudparts.log.data.LogRec.session)
}
inline ::std::string* LogRec::mutable_session() {
  set_has_session();
  // @@protoc_insertion_point(field_mutable:cloudparts.log.data.LogRec.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRec::release_session() {
  // @@protoc_insertion_point(field_release:cloudparts.log.data.LogRec.session)
  clear_has_session();
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRec::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    set_has_session();
  } else {
    clear_has_session();
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:cloudparts.log.data.LogRec.session)
}

// optional uint32 facility = 11;
inline bool LogRec::has_facility() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LogRec::set_has_facility() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LogRec::clear_has_facility() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LogRec::clear_facility() {
  facility_ = 0u;
  clear_has_facility();
}
inline ::google::protobuf::uint32 LogRec::facility() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.facility)
  return facility_;
}
inline void LogRec::set_facility(::google::protobuf::uint32 value) {
  set_has_facility();
  facility_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.facility)
}

// optional uint32 severity = 12;
inline bool LogRec::has_severity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LogRec::set_has_severity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LogRec::clear_has_severity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LogRec::clear_severity() {
  severity_ = 0u;
  clear_has_severity();
}
inline ::google::protobuf::uint32 LogRec::severity() const {
  // @@protoc_insertion_point(field_get:cloudparts.log.data.LogRec.severity)
  return severity_;
}
inline void LogRec::set_severity(::google::protobuf::uint32 value) {
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:cloudparts.log.data.LogRec.severity)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace data
}  // namespace log
}  // namespace cloudparts

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cloudparts::log::data::TxInfo_TEvt> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cloudparts::log::data::TxInfo_TEvt>() {
  return ::cloudparts::log::data::TxInfo_TEvt_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_data_2eproto__INCLUDED
